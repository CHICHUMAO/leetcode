给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

 

示例 1：

输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
示例 2：

输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101

#include <stdint.h>
#include <stdlib.h> // 添加malloc所需头文件

// 返回≤n的最大2的幂（优化版）
int largestPowerOfTwo(int n) {
    if (n <= 0) return 0;
    int result = 1;
    while (result <= n/2) { // 避免溢出
        result <<= 1;
    }
    return result;
}

int* countBits(int n, int* returnSize) {
    // 1. 设置返回数组大小
    *returnSize = n + 1;
    
    // 2. 安全分配内存
    int *dp = (int*)malloc((n + 1) * sizeof(int));
    if (dp == NULL) {
        *returnSize = 0; // 内存分配失败
        return NULL;
    }
    
    // 3. 初始化基础值
    dp[0] = 0; // 0的二进制没有1
    
    // 4. 动态规划计算
    for (int i = 1; i <= n; i++) {
        // 关键公式：i的比特数 = 1 + (i去掉最高位后的值对应的比特数)
        int highestPower = largestPowerOfTwo(i);
        dp[i] = 1 + dp[i - highestPower];
    }
    
    return dp;
}
