给你一个字符串 s，找到 s 中最长的 回文 子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"

#include <string.h>
#include <stdlib.h>

char* longestPalindrome(char* s) {
    int len = strlen(s);
    if (len == 0) return "";

    int start = 0, max_len = 1; // 记录最长回文起止

    // 检查所有可能的中心点（兼容奇偶）
    for (int i = 0; i < len; i++) {
        // 奇数长度回文（中心为i）
        int left = i, right = i;
        while (left >= 0 && right < len && s[left] == s[right]) {
            int cur_len = right - left + 1;
            if (cur_len > max_len) {
                start = left;
                max_len = cur_len;
            }
            left--;
            right++;
        }

        // 偶数长度回文（中心为i和i+1）
        left = i;
        right = i + 1;
        while (left >= 0 && right < len && s[left] == s[right]) {
            int cur_len = right - left + 1;
            if (cur_len > max_len) {
                start = left;
                max_len = cur_len;
            }
            left--;
            right++;
        }
    }

    // 动态分配内存存储结果
    char* result = (char*)malloc(max_len + 1);
    if (!result) return NULL;
    strncpy(result, s + start, max_len);
    result[max_len] = '\0';
    return result; // 调用方需free(result)
}

动态规划，但是需要注意奇数偶数的判定区别，同时对于c语言string.h函数需要熟识。
找好dp就很简单，最小子结构。
